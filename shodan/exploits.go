// The Exploits API provides access to several exploit/ vulnerability data sources. At the moment,
// it searches across the following:
package shodan

type (
	// Exploit DB,  Metasploit or Common Vulnerabilities and Exposures (CVE)
	ExploitSource string

	// Platform type
	ExploitPlatform string

	// Exploit type
	ExploitType string
)

const (
	exploitSearchPath = "/search"
	exploitCountPath  = "/count"

	ExploitSourceCVE        ExploitSource = "CVE"
	ExploitSourceMetasploit ExploitSource = "Metasploit"
	ExploitSourceExploitDB  ExploitSource = "ExploitDB"

	ExploitTypeDOS       ExploitType = "dos"
	ExploitTypeExploit   ExploitType = "exploit"
	ExploitTypeLocal     ExploitType = "local"
	ExploitTypeRemote    ExploitType = "remote"
	ExploitTypeShellcode ExploitType = "shellcode"
	ExploitTypeWebapps   ExploitType = "webapps"

	ExploitPlatformAix      ExploitPlatform = "aix"
	ExploitPlatformCGI      ExploitPlatform = "cgi"
	ExploitPlatformFreeBSD  ExploitPlatform = "freebsd"
	ExploitPlatformHardware ExploitPlatform = "hardware"
	ExploitPlatformJava     ExploitPlatform = "Java"
	ExploitPlatformJSP      ExploitPlatform = "jsp"
	ExploitPlatformLin86    ExploitPlatform = "lin_x86"
	ExploitPlatformLinux    ExploitPlatform = "Linux"
	ExploitPlatformMultiple ExploitPlatform = "multiple"
	ExploitPlatformNovell   ExploitPlatform = "novell"
	ExploitPlatformOSX      ExploitPlatform = "osx"
	ExploitPlatformPHP      ExploitPlatform = "PHP"
	ExploitPlatformTrue64   ExploitPlatform = "true64"
	ExploitPlatformUnix     ExploitPlatform = "Unix"
	ExploitPlatformWindows  ExploitPlatform = "Windows"
)

type Exploit struct {
	// Unique ID for the exploit/ vulnerability (integer or string)
	ID interface{} `json:"_id"`

	// An array of Bugtraq IDs that reference this vulnerability
	BID []int `json:"bid"`

	// An array of relevant CVE IDs that reference this exploit
	CVE []string `json:"cve"`

	// An array of Microsoft Security Bulletin reference IDs for this exploit
	MSB []string `json:"msb"`

	// An array (integer or string) of OSVDB IDs that are relevant to this exploit
	OSVDB []interface{} `json:"osvdb"`

	// A description explaining the details of the exploit
	Description string `json:"description"`

	// The name of the data source
	Source ExploitSource `json:"source"`

	// The author of the exploit/vulnerability
	Author interface{} `json:"author"`

	// The actual code for the exploit
	Code string `json:"code"`

	// The timestamp for when the exploit was released in the UTC timezone. Example: "2014-01-15T05:49:56.283713"
	Date string `json:"date"`

	// An array of platforms or a single platform that the exploit targets
	Platform interface{} `json:"platform"`

	// The port number for the affected service
	Port int `json:"port"`

	// The type of exploit
	Type ExploitType `json:"type"`

	// Is Privileged?
	Privileged bool `json:"privileged"`

	// Rank, i.e. "excellent"
	Rank string `json:"rank"`

	// Version
	Version string `json:"version"`
}

type ExploitSearchOptions struct {
	// Search query used to search the database of known exploits
	Query string `url:"query"`

	// A comma-separated list of properties to get summary information on
	Facets string `url:"facets,omitempty"`

	// The page number to page through results 100 at a time. It is ignored in CountExploits method
	Page int `url:"page,omitempty"`
}

type ExploitSearch struct {
	Matches []*Exploit          `json:"matches"`
	Facets  map[string][]*Facet `json:"facets"`
	Total   int                 `json:"total"`
}

// Search across a variety of data sources for exploits and use facets to get summary information
func (c *Client) SearchExploits(options *ExploitSearchOptions) (*ExploitSearch, error) {
	if options == nil || options.Query == "" {
		return nil, ErrInvalidQuery
	}

	url, err := c.buildExploitBaseURL(exploitSearchPath, options)
	if err != nil {
		return nil, err
	}

	var found ExploitSearch
	err = c.executeRequest("GET", url, &found, nil)

	return &found, err
}

// This method behaves identical to the "/search" method with the difference that it doesn't return any results
func (c *Client) CountExploits(options *ExploitSearchOptions) (*ExploitSearch, error) {
	if options == nil || options.Query == "" {
		return nil, ErrInvalidQuery
	}

	url, err := c.buildExploitBaseURL(exploitCountPath, options)
	if err != nil {
		return nil, err
	}

	var found ExploitSearch
	err = c.executeRequest("GET", url, &found, nil)

	return &found, err
}
